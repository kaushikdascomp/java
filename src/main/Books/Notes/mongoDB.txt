Use MongoTemplate just like jdbc template to connect to database. It uses the template pattern and allows to execute commands
against a mongo database

And it has different features like .save/update like hibernate to update the collection
MongoDB, everything is stored in collection

@Document- Annote class to store objects as collection in DB
or @Document("flights")
@Indexed - To index a particular field
@CompoundIndex- To index multiple fields and can specify the ascending and descending order as well
@TextIndexed- When we want to query the DB on text based search as well
@DbRef - When we want to store a collection inside collection as separate entity and not within the same collection

Query Execution:
Without indexes- Collection scan, each document is evaluated, slow search but fast insert and delete
With indexes- Doesn't scan every document, fast search but slow insertion and deletion

@textIndexed private string title;(Default weight is one)
@TextIndexed(weight =2 )private String aboutMe; -- about me is two times more important than title while searching

Duplicate key exception- In case of where an id already exists and the next document we want to insert it use the same id
Then it will not save the document, it will throw duplicate key exception

MongoDB batch insert:
List<Persons> persons =  ARrays.asList(a,b,c);
mongoTeplate.insertAll(persons)

Update: first get the document by id and then update the document with the new record. If no document exists it will create
a new document else it will update the existing which is just a complete replace 
mongoTemplate.save(person)

Read/Write converters: When you want to specified object to store in a different format instead of the original one.
Eg: class Person{
String name;
Address adddress;

["Person":"person 1",
"Address":{
	"city":"paris",
	"country":"france"
}]	

to
["Person":"person 1",
"Address":"Paris,france"
	]
Then you require a write converter to write the data to mongo and a read converter to read it from mongo

MongoRepository:
Instead of using template, mongorepository provies some boiler plate code to do basic crud operations 
Spring data itself provides 3 interfaces:
Repository<T,ID>
CrudRepository<T,ID>-- Operations like save, saveAll, findAll,findById,exists,delete,count
PagingAndSortingRepository<T,ID>-- findAll(Sort s), findAll(Pageable p)

Mongo provides one more repository:
MongoRepository<T,ID>: insert(T o), insert(Iterable<T> list)
Repositories are great at abstracting the persistence layer. Improved type safety and cleaner code but not for complex queries

Lifecycle events:
save/insert lifecycle
onBeforeConvert- is called before the java object is converted to a document by mongoconverter
onBeforeSave()- is called before inserting or saving the document in the mongo
onAfterSave()- is called after the document is inserted or saved in the db

Load Documents:
onAfterLoad- is called afer the document is retrieved from DB
onAfterConvert- After the document has been converted to POJO 

