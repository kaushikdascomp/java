lazy Initiation and early initiation
In lazy loading, singleton class is created only when client calls getInstance()
In early loading singleton class is created when class is loaded into memory

Double checked locking in Singleton pattern

DCLSP getInstance() method checks two times to see whether instance is null or not

http://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.html

http://www.javacodegeeks.com/2013/02/singleton-design-pattern-an-introspection-and-best-practices.html

Best way for creating singleton classes are enums but there is one more way using nested static class:
public class Singleton{
private Singleton(){
}
private static class SingletonHelper{
private static final Singleton INSTANCE= new Singleton(){
}
public static BillPughSingleton getInstance(){
        return SingletonHelper.INSTANCE;
    }

Diff between static class and singleton class

Simmiliarities:methods inside both the classes can be called without instantiating the classes
Allows creation of only single object no matter how many times a static block is called

Diff-Static class provides better performance than singleton because static methods are bonded on compile time
Ability to override-Static classes methods cannot be overriden whereas methods in singleton classes can be overriden in base class
Singleton class is lazy loaded i.e. loaded whenever necesaary calling the new constructor object whereas static class is loaded immediately
into memory.

Singleton class cannot extend classes and implement interfaces whereas static class cannot 
Singelton class cannot be extended as the default constructor is private 
SC is lazy loaded while static class is loaded immediately
We cannot override methods in static class
all members are static in Static class
Singleton object in heap and static object in stack
Static methods can access only static variables of class and invoke only static methods of the class
Java Static block are group of statements that gets executed when class is loaded into memory.
It is used to initialize static variables of the class

Only nested static class can be static

If you can inherit Singleton, it's not really a singleton, since each inherited class will have at least one instance and the private 
constructor will prevent it from creating a new instance

When you have a class A extends B, an instance of A essentially has an instance of B in it.
 So the very concept of inheritance is contrary to the singleton model.

Fundamental difference between singleton and static class: One represents object while other represent just static methods

http://javarevisited.blogspot.in/2013/03/difference-between-singleton-pattern-vs-static-class-java.html

TO prevent cloneable interfaces from initializing in singleton
override clone method with throws clonenotSupportedOperation which will throw clonenotSupportedOperation 
http://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples

Serialization and deserialization can break singleton as during deserialiaztion we can get two or more object
To break this we need to ovveride the readresolve method
protected Object readResolve() {
    return getInstance();
}
