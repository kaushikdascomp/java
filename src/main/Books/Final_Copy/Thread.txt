More than one call statck, multiple processes running at a time. In reality only a true multiple processor can process multiple threads at a 
time but with Java threads it appears that we are doing multiple things simultaneously

Launching new thread:
1. Make a runnable object-It is where we define the tasks/work that the thread is required to perform in a class
Runnable threadJob=new MyRunnable();
2. Make a thread object-This is the thread which will execute the runnable interface or job and pass the runnable object in the thread
Thread myThread=new Thread(threadJob);
3. Start the thread- myThread.start();

Runnable class has run() method which excutes and places the method at the bottom of the stack
Create a class MyRunnable implementing the Runnable interface and provide the method run() and define our task inside the method
A thread is not really a thread untill we start the thread and after starting new methods created it moves to the top of the stack

Three states of a thread:New, Runnable, Running
New-Created the thread but not started
Runnable-started the thread. At this point there is a new call stack for this thread
Running-In this state, a thread has an active call stack & runs that method which is on top. Scheduled by JVM thread scheduler

Main thread and newly created thread runs parallely and it depends on JVM thread scheduler who gives preference to methods inside newly created 
thread. It may be like newly created thread finished first executing or main thread finished executing first

Sleep(ms)-A thread can be put to sleep from running state to out of runnable state. But after it wakes up, it may throw an exception, thus
the sleep method must be put into try/catch block 

Thus sleep method is like a controller which will control the other thread to finish its task and then run. Thus JVM thread scheduler will pick
the one which has finished its task

Synchronized provides a lock in two threads which are both running but it may lead to ambiguity, so one thread must be finished before the other 
thread starts

If an object has synchronized, a thread can enter one of the synchronized methods only if the key of objects lock is available i.e.if an object
has two synchronized methods there is still one key available. Once an object enters a synchronized method, no other thread can enter the other sync method

Deadlock- Thread deadlock happens when we have two threads and both of which are holding a key the other thread wants. Java has no mechanism to handle
deadlocks

Demerits of synchronization:
performance issue
can slow the program, a synchronized thread forces other methods to be in line and wait for his turn
It can lead to deadlock

Callable and Runnable-Both are intefaces. Callable has methid call() and Runnable has run() method. call() can return values and can handle exceptions
 while in run() the return type is void and cannot handle exceptions

Call() can throw checked exception while in run it cannot throw checked exception
A Semaphore is a thread synchronization construct that can be used either to send signals between threads to avoid missed signals,
 or to guard a critical section like you would with a lock
http://tutorials.jenkov.com/java-concurrency/semaphores.html

You can convert callable to runnable using the following task
Callable callable = Executors.callable(Runnable task)

You cannot execute a callable instance in a thread but runnable you can
Why because there is no constructor defined in thread class to take callable interface
Only with executor service you can use callable
ExecutorService exec = Executors.newFixedThreadPool(10);
Future result = exec.submit(aCallable)  -- Can pass both callable and runnable whereas in execute only can pass runnable

Submit will return a future object but execute doesn't return anything
Submit can accept both runnable and callable task but execute only takes runnable task

Thread Join:
How to ensure that 3 threads T1,T2 and T3 finishes one after the another
T1.join from T2 and T2.join from T3

Countdown Latch and Cyclic Barrier

Both are used to implement a scenario where one thread waits for one or more threads to complete their job before it starts 
processing.
COuntdown latch cannot be reused once it reaches 0 whereas you can use the cyclic barrier after the barroier is broken
The CyclicBarrier uses a fast-fail all-or-none breakage model for failed synchronization attempts: 
If a thread leaves a barrier point prematurely because of interruption, failure, or timeout, all other threads, even those that have not yet resumed from a previous await(), will also leave abnormally via BrokenBarrierException (or InterruptedException if they too were interrupted at about the same time).

Read more: http://www.java67.com/2012/08/difference-between-countdownlatch-and-cyclicbarrier-java.html#ixzz4W2zFGTo4
One major difference is that CyclicBarrier takes an (optional) Runnable task which is run once the common barrier condition is met.
http://javarevisited.blogspot.in/2012/07/cyclicbarrier-example-java-5-concurrency-tutorial.html