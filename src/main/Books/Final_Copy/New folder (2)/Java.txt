Diff between Instance and local variables:

instance variable are declared inside a class whereas local variables such as int a; are declared inside a method
Local variables must be defined before use whereas in case of instance variables, it is automatically initialized such as int to 0

Typecasting: int randomNum=(int)(Math.random()*5); mathrandom returns double so typecasting it to int
long y=42; 
int x=y;-- Compile error

int x=(int) y--No eror
public memebers are inherited whereas private members are not inherited
Inherited methods can be overriden while instance variables cannot be overridden

If only return type is different, it is method overriding not method overloading

Abstract class must be extended at all times whereas abstract method must be overriden
All abstract methods must be implemented. It must be overriden in base class

Putting objects in arraylist- ArrayList<object> myDogArraylist=new ArrayList<object>(); Dog aDog=new Dog(); myDogArrayList.add(aDog);
Dog d=myDogArrayList.get(0);-- It will not compile and come out as object not dog object. But we can get Dog object by typecasting it
Dog d=(Dog) myDogArrayList.get(0); only when we know that it is a dog object

Garbage collection-We actually do not destroy the object, we abandon it and all abandoned objects are picked up by garbage collector which is
a daemon thread
Heap-where objects live; stack-where method invocations and local variables
local variables also known as stack variables

On the top of the stack, superclass constructors are invoked--on top object, animal, hippo
Static methods is not meant to be instantiated
All instances of same class share a single copy of static variables
Static variables are initialized before any object of that class can be created
A variable is marked static, so that we don't need an instance to create that method or class/not allowed to create instance

Final method-cannot be overriden/Final variable-can't change/Final class-can't extend
A static method can't access

Wrapping a primitive-int i=288; Integer iWrap=new Integer(i);
Unwrapping- int unWrapped=iWrap.intValue();

JAVA 8 Features:

Scope: In lambda expression you can only reference variables whose value doesn't change
Lambda expression can only access local variables from an enclosing scope and that are effectively final
A final variable is never modified